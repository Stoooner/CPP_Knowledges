## 内存管理
### 1. 内存的分区模型——基本概念内容
>1. C++程序在执行的时候，将内存大方向划分为了4个区域：
>- **代码区：** 你写的所有代码最终编译成的机器码都会存放在代码区，代码区存放着函数体的二进制代码，由操作系统进行管理；
>- **全局区：** 存放全局变量和静态变量以及常量；
>- **栈区：** 由编译器自动分配释放，存放函数的参数值，局部变量等；
>- **堆区：** 由程序员分配和释放，若程序员不释放，程序结束后由操作系统回收；
>
>2. 内存四区存在的意义：
>- **不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程**；
>
>3. 程序运行之前：在程序编译后，生成了exe可执行文件，未执行该程序之前分为两个区域：
>- **代码区：**
>>- 存放CPU执行的机器指令；
>>- 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可；
>>- 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令；
>- **全局区：**
>>-  **全局变量**和**静态变量**存放在此；
>>-  全局区还包含**常量区**，**字符串常量**和**其他常量**(**const修饰的一些全局变量**)也存放在此；
>>-  该区域的数据在程序结束后由操作系统释放；
>
>4. 程序运行之后：
>- **栈区：**
>>- 由编译器自动分配释放，存放函数的参数值，局部变量等；
>>- 注意事项：不要返回局部变量的值，因为栈区开辟的数据由编译器自动释放；
>- **堆区：**
>>- 由程序员分配释放，若程序员不释放，程序结束后会由操作系统回收；
>>- 在C++中主要利用new在堆区开辟内存；
>
>5. new操作符：
>- C++利用new操作符在堆区开辟数据；
>- 堆区开辟的数据有由程序员手动开辟，手动释放，释放时利用操作符delete；
>- 利用new创建的数据，会返回该数据对应的类型的指针；

### 2.  示例代码
```c++
#include <iostream>
using namespace std;
/* 
    1. C++程序在执行的时候，将内存大方向划分为了4个区域：
        - 代码区：你写的所有代码最终编译成的机器码都会存放在代码区，代码区存放着函数体的二进制代码，由操作系统进行管理；
        - 全局区：存放全局变量和静态变量以及常量；
        - 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；
        - 堆区：由程序员分配和释放，若程序员不释放，程序结束后由操作系统回收；
    2. 内存四区存在的意义：
        - **不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程**；
    3. 程序运行之前：
        在程序编译后，生成了exe可执行文件，未执行该程序之前分为两个区域：
            代码区：
                - 存放CPU执行的机器指令；
                - 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可；
                - 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令；
            全局区：
                - 全局变量和静态变量存放在此；
                - 全局区还包含常量区，字符串常量和其他常量(const修饰的一些全局变量)也存放在此；
                - 该区域的数据在程序结束后由操作系统释放；
    4. 程序运行之后：
        栈区：
            - 由编译器自动分配释放，存放函数的参数值，局部变量等；
            - 注意事项：不要返回局部变量的值，因为栈区开辟的数据由操作系统自动释放；
        堆区：
            - 由程序员分配释放，若程序员不释放，程序结束后会由操作系统回收；
            - 在C++中主要利用new在堆区开辟内存；
    5. new操作符：
        - C++利用new操作符在堆区开辟数据；
        - 堆区开辟的数据有由程序员手动开辟，手动释放，释放时利用操作符delete；
        - 利用new创建的数据，会返回该数据对应的类型的指针；
    
    6. https://www.jianshu.com/p/98cb5f584a31；
    7. https://juejin.cn/post/6844904148043825159；
*/

// 全局变量：
int g_a = 10;
int g_b = 10;
// const修饰的全局变量-->全局常量
const int c_g_a = 10;
const int c_g_b = 10;

// 错误演示，记住不要返回局部变量的地址
int* func(int b){ // 形参数据也会放在栈区
    b = 100;
    int a = 10;// 局部变量，存放在了栈区，栈区的数据在函数执行完后自动释放
    return &a;
}

int* func2(){
    // 利用new关键字可以将数据开辟到堆区
    // new int(10)在堆区开辟空间存放数据，并会返回这个空间的地址，因此使用指针int *p去接收
    // 这个指针本质也是局部变量，放在栈上，指针保存的数据是放在了堆区
    // 这个p指针是栈区的局部变量，在return之后就被释放了，但是return的时候系统会生成这个栈区的局部变量的拷贝，并将这个拷贝给与main函数中接收的p2，因此这里p指针在func2结束后释放掉也没有关系；
    int* p = new int(10);
    // int* p = (int*)malloc(sizeof(int));
    return p;
}

void test01(){
    int *p = func2();
    cout << "xxx: " << *p << endl; 
    cout << "xxx: " << *p << endl; 
    cout << "xxx: " << *p << endl; 
    // delete调用析构函数，用于释放堆区的数据,指针p指向的内存被释放且在析构函数中指针p被置为空，防止野指针；
    delete p;
    cout << "xxx: " << *p << endl; // 内存已被delete释放，再次访问就是非法操作，会报错
}

// 在堆区利用new开辟数组
void test02(){
    // 这里中括号[10]代表的是创建一个包含10个"int型元素"的数组，里面每个元素默认值为0；
    int * arr = new int[10];
    for (int i=0;i<10;i++){
        arr[i] = i + 100; // 或者*(arr+i) = i + 100;
    }
    for (int i=0;i<10;i++){
        cout << arr[i] << endl;
    }
    // 释放堆区数组，需要加[]才可以；
    delete[] arr; 
}

int main(){
    // 全局区： 全局变量、静态变量、常量(全局常量、字符串常量)

    // 创建一个普通的局部变量(写在函数体内的变量)：
    int a = 10;
    int b = 10;
    cout << "局部变量a的地址: " << (long long)&a << endl; 
    cout << "局部变量b的地址: " << (long long)&b << endl; 
    cout << "全局变量g_a的地址: " << (long long)&g_a << endl; 
    cout << "全局变量g_b的地址: " << (long long)&g_b << endl; 

    // 静态变量
    static int s_a = 10;
    static int s_b = 10;
    cout << "静态变量s_a的地址: " << (long long)&s_a << endl; 
    cout << "静态变量s_b的地址: " << (long long)&s_b << endl; 

    // 常量：字符串常量，const修饰的变量
    cout << "字符串常量的地址： " << (long long)&"hello world" << endl;
    cout << "全局常量的地址： " << (long long)&c_g_a << endl;
    cout << "全局常量的地址： " << (long long)&c_g_b << endl;
    // const修饰的局部变量--->局部常量，它虽然是常量，但是由于是局部的，因此它不在全局区，它和局部变量一样，都不在全局区
    const int c_l_a = 10;
    const int c_l_b = 10;
    cout << "局部常量的地址： " << (long long)&c_l_a << endl;
    cout << "局部常量的地址： " << (long long)&c_l_b << endl;
    // 注意：局部常量自己不能修改值，但是可以通过指向它的指针进行修改
    int* ptr = &c_l_a;
    *p = 20;

    // 通过测试上述代码就可以发现，局部变量的地址挨的比较近
    // 而全局变量、静态变量、字符串常量和全局常量的地址挨的比较近
    // 但是局部常量不在全局区，因此跟局部变量离得不远


    // 接收func返回的值(错误示例)
    int *p = func(1);
    // cout << "返回局部变量的地址示例1： " << *p << endl; // 第一次的时候，func()运行结束了，在退出函数的时候，系统只是修改了这块栈顶的指针，并没有清内存，因此这个内存还是原来的值，所以是有可能正常访问到局部变量的内存的。这个地址释放后操作系统会标记该地址为可用状态，但值还是没变，直到操作系统分配该地址到其他数据或者程序；
    // cout << "返回局部变量的地址示例2： " << *p << endl; // 但是第二次的时候，因为栈是系统自动管理的，所以该内存可能会被分配给其他函数，这样，该内存的内容就会被覆盖，不再是原来的值了；
    /*
        1. 函数调用返回后，栈上的数据并没有被清空，而程序失去了对栈所在内存的控制权，因此第一次打印的时候由于原来在的内存还没有被覆盖，因此可以输出，而第二次输出的时候已经被别的数据覆盖了，所以输出的内存不可控；
        2. https://blog.csdn.net/tujinqiuqq85948239/article/details/27236677；
        3. https://blog.csdn.net/weixin_37818081/article/details/78627588；
        4. 第一个能得到正确结果原因在于，C++的内存清理机制是惰性的，要等到下一位住客住进来，它才会进行内存的清理，因而在程序中，第一次可以得到正确的结果；
        5. https://blog.csdn.net/supreme42/article/details/7636370；
        6. 这个错误其实可以利用起来，例如：运用到某些保密的东西，比如实时验证码之类的，当前只发送一次；
        7. 小问题思考：为什么函数可以返回局部变量，而不能返回局部变量的地址呢？
           解答：函数的局部变量用作返回值时，会生成一个局部变量的拷贝用作返回值，之后局部变量会被系统回收，
                函数不能返回局部变量的地址，因为如果返回局部变量的地址，系统回收后，指针指向的内容就无意义了，
                但是对于静态变量也可以返回其指针。(1. https://blog.csdn.net/yangzhen19900701/article/details/9731657)/(2. https://blog.csdn.net/gogokongyin/article/details/51472062)         
    */

    // 堆区
    // 堆区的数据不会改变，在栈上创建的指针指向堆区的内存，栈上的指针会释放，但是堆区的数据不会释放。每次指向都是。
    // main中的*p2指向的就是堆区变量的地址，因为不会释放，所以*p可以一直使用
    // 运行后栈区里面的指针p(func2中的指针变量p)被释放掉，但释放之前通过return返回了一个拷贝给了main里面的指针p2，在这个返回过程中，堆区里的数据都没有改变，所以main里面的指针p2就可以正常接收了
    // func2函数返回的指针p在func2结束之前系统会创建拷贝给main函数中新建的指针p2接收，所以func中的p在结束后被释放掉也不影响
    // 因此注意一点：main中的指针P2和func2函数中的指针p是不一样的，func2中指针p指着的地址返回给到了main中的p2指针，所以只要Main函数不结束，Main中的指针p2就一直存在，而堆区的数据又不会被系统自动释放，因此就p2指针就能一直指着那个堆区的地址；
    int* p2 = func2();
    // 只要我不去释放在堆区开辟的空间的数据，这个数据就会一直保留，除非程序运行完毕，然后被系统给回收
    cout << "返回堆区数据的地址示例1： " << *p2 << endl;
    cout << "返回堆区数据的地址示例2： " << *p2 << endl; 

    test01();
    test02();

    system("pause");
    return 0;
}
```